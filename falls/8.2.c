/*
* 简单格式类型
*/
#include<stdio.h>
#include<math.h>

main(){
	//%d格式项请求打印一个整数，因此后面必须有一个相应的整型参数。
	//当格式字符串被复制到输出文件时，其中的%d格式项将被对应的待输出整数的10进制值替换，
	//替换时不会在整数值的前后添加空格字符。
	printf("2+2=%d\n",2+2);
	
	//char型和short型的参数会被自动扩展为int型。在把char类型的值视为有符号整数的机型上，结果会让人吃惊。
	char c = -129;//警告：隐式常量转换溢出
	char c1 = 128;
	printf("%d,%d,%d,%u\n",-0,c,c1,-37);
	
	//%o大于八进制，%x和%X打印十六进制
	int n = 108;
	printf("%d decimal = %o octal = %x hex = %X hex\n", n, n, n, n);
	
	//%s格式项所对应输出的字符串必须以一个空字符('\0')作为结束标志。因为printf函数要以此来定位一个字符串何时结束，
	//舍此别无他法。如果与%s对应字符串不是以空字符('\0')作为结束标志，那么printf将不断打印出其后的字符，直到在内存
	//中某处找到一个空字符('\0')。最终的输出可能相当长！
	n = 1;
	printf("There %s %d item%s in the list.\n",n!=1?"are":"is",n,n!=1?"s":"");
	n = 37;
	printf("There %s %d item%s in the list.\n",n!=1?"are":"is",n,n!=1?"s":"");
	
	char *cp = "";
	printf("'%s'",cp);
	
	char *s = "%s";
	//printf(s);//第1个例子将把字符串s中的任何%字符视为一个格式项的标志，因而其后的字符会被视为格式码。
	//如果除%%之外的任何格式码在字符串s中出现，而后面又没有对应的参数，将会带来麻烦。
	printf(s,s);
	//printf("%s\n",NULL);//Segmentation fault(core dumped)
	
	//与%c格式项对应的参数是一个为了打印输出而被转换字符型的整型值。
	printf("\nThe decimal equivalent of '%c' is %d\n",'*','*');
	
	//%g用于打印那些不需要按列对齐的浮点数特别有用。它在打印浮点型或双精度数值尾缀的零，保留六位有效数字。
	printf("Pi = %g\n",4*atan(1.0));
	printf("%g %g %g %g %g %g\n",1/1.0,1/2.0,1/3.0,4/3.0,1/4.0,0.0);
	//打印出超过6位的有效数字
	printf("%g\n",123456789.0);
	//对小的数值，除非该数指数小于或等于-5，%g格式项才会采用科学计数法来表示。
	printf("%g %g %g\n",3.14159e-3,3.14159e-4,3.14159e-5);
	
	//%e格式项用于打印浮点数时，要求一律显式地使用指数形式：
	//%e打印出小数点后6位有效数字，而并非%g打印出的数总共6位有效数字。
	printf("%e\n",3.141593e+00);
	
	//%f格式项恰好相反，强制禁止使用指数形式来表示浮点数。%f与%e格式项相同，即小数点后6位有效数字。
	printf("%f\n",1e38);//打印出数值的数字位数，超过了大多数硬件能够表示的精度范围。
	
	//%E和%G格式项与它们对应的%e和%g格式项行为相同，用大写E代替小写e
	printf("%E %G",3.1415926573184,3.1415926573184);
	
	//%%打印一个%字符
	printf("\n%%d prints a decimal value %D\n",10);
}
