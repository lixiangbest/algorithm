/*
* 一般编译器每次只处理一个文件，它不能检测出那些需要一次了解多个源程序文件才能察觉的错误
* 某些C语言实现提供了一个称为lint的程序，可捕获到大量的此类错误。
* 连接器：C语言的一个重要思想就是分别编译(Separate Compilation)，即若干个源程序可在不同时候单独进行编译
* 然后在恰当的时候整合到一起。但是连接器一般是与C编译器分离的，它不可能了解C语言的诸多细节。
* 尽管连接器并不理解C语言，然而它却能够理解机器语言和内存布局。编译器的责任是把C源程序“翻译”成对连接器有意义的形式，
* 这样连接器就能够“读懂”C源程序了。
*
* 4.3 命名冲突与static修饰符
* static能减少自定义函数与库函数中名称同名的冲突，适用于变量也适用于函数。如果一个函数仅仅被同一个源文件中的其他函数调用，我们就应该声明该函数为static.
*/
#include<stdio.h>

//定义外部变量
int a;//位置出现在所有的函数体之外，那么它就被称为外部对象a的定义。这个语句说明了a是一个外部整型变量，
//同时为a分配了存储空间。因为外部对象a并没有被明确指定任何初始值，所以它的初始值默认为0.(某些系统的连接器对其他语言编写的程序并不保证这一点，C编译器有责任以适当方式通知连接器，确保未指定初始值的外部变量被初始化为0)。

//并不是对a的定义，它说明a是一个外部整型变量，而包含extern关键字显式说明了a的存储空间是在程序的其他地方分配的。
//从连接器角度看，上述声明是一个对外部变量a的引用，而不是对a的定义。因为这种形式的声明是对一个外部对象的显式引用。
// extern int a;

int random_seed;

/*
//如果一个函数仅仅被同一个源文件中的其他函数调用，我们就应该声明该函数为static.
static void srand(int n){
	//每个外部对象都必须在程序某个地方进行定义。如果一个程序中包括下面语句，这两个语句既可以是在同一个源文件中，也可以位于程序的不同源文件之中。
	extern int random_seed;
	random_seed = n+1;
}
*/

main(){
	printf("a=%d,random_seed=%d\n",a,random_seed);
	//void srand(int);//定义在4.1a.c中，如果有两个函数srand,则只调用定义为static的函数，同名函数不同文件，在调用函数的本文件中定义为static的函数优先级较高
	srand(5);//一个未声明的标识符后跟一个开括号，那么它将被视为一个返回整型的函数。
	printf("random_seed=%d\n",random_seed);
	
	static int sa;//sa的作用域限制在一个源文件内，对于其他源文件，sa是不可见的。如果若干个函数需要共享一组外部对象，可将这些函数放到一个源文件中，把它们需要用到的对象也都在同一个源文件中以static修饰符声明。
	
	//保证一个特定名称的所有外部定义在每个目标模块中都有相同的类型，一般来说是程序员的责任。否则可能出现未知错误。
	extern int en;//注意4.1a.c中en定义的变量类型不同，本来错误的程序因为某种巧合却能够工作
	printf("extern:0x%x\n",en);
	
	extern short foo;//注意4.1a.c中en定义的变量类型不同，本来错误的程序因为某种巧合却能够工作
	printf("extern:%d\n",foo);
	
	return 0;
}