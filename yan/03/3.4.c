typedef struct{	int x;//x坐标	int y;//y坐标	int val;//maze[x][y]的值}elemType;//别名声明，其实int可以用任意的数据类型代入#define NL "\n" //格式化输出函数#define D "%c"#define DL D NL#include "stack.c"/*初始化迷宫，1表示通道，0表示墙*/int maze[8][8] = {	1,1,0,1,1,1,0,1,	1,1,0,1,1,1,0,1,	1,1,1,1,0,0,1,1,	1,0,0,0,1,1,1,1,	1,1,1,0,1,1,1,1,	1,0,1,1,1,0,1,1,	1,0,0,0,1,0,0,1,	0,1,1,1,1,1,1,1};//判断当前位置是否走过int unPass(sLink S,elemType e){	eLink p=S->top;//如果指向下一个元素，可能栈空	while(p!=S->base){		p--;		if(p->x==e.x&&p->y==e.y) return false;//已经走过	}	return true;//没有走过}//获得东面相邻的位置,这里是传值，非传地址elemType getEast(elemType e){	//当y==7时已到了迷宫右边界，不能再向东(右)行了	if(e.y!=7){		e.y+=1;		e.val = maze[e.x][e.y];	}	return e;//当y==7时返回的是它本身}//获得南面相邻的位置elemType getSouth(elemType e){	//当x==7时已到了迷宫下边界，不能再向右南(下)行了	if(e.x!=7){		e.x += 1;		e.val = maze[e.x][e.y];	}	return e;//当x==7时返回的是它本身}//获得西面相邻的位置elemType getWest(elemType e){	//当y==0时已到了迷宫右边界，不能再向西(左)行了	if(e.y!=0){		e.y-=1;		e.val = maze[e.x][e.y];	}	return e;//当y==0时返回的是它本身}//获得北面相邻的位置elemType getNorth(elemType e){	//当x==7时已到了迷宫下边界，不能再向右南(下)行了	if(e.x!=0){		e.x -= 1;		e.val = maze[e.x][e.y];	}	return e;//当x==0时返回的是它本身}//获得下一个可通行的位置，按东南西北的方向试探elemType getNext(sLink S,elemType e){	elemType next;	next.x = next.y = next.val = -1;	if(getEast(e).val!=0&&unPass(S,getEast(e))){		next = getEast(e);	}else if(getSouth(e).val!=0&&unPass(S,getSouth(e))){		next = getSouth(e);	}else if(getWest(e).val!=0&&unPass(S,getWest(e))){		next = getWest(e);	}else if(getNorth(e).val!=0&&unPass(S,getNorth(e))){		next = getNorth(e);	}	//如果当前位置的四面或为墙或已走过，则返回的next的val值为-1	return next;}//获得迷宫路径的函数void getMazePath(sLink realPath, sLink path){	elemType start,end,curpos;	start.x = 0;start.y = 0;start.val = maze[start.x][start.y];	end.x = 7;end.y = 7;end.val = maze[end.x][end.y];	curpos = start;//设定当前位置为“入口位置”	//printf("%d %d %d",curpos.x,curpos.y,curpos.val);//0 0 1	do{		if(unPass(path,curpos)){//如果当前位置未曾走到过			push(realPath,curpos);			push(path,curpos);			curpos = getNext(path,curpos);//顺时针旋转找到下一个位置			//到达出口了，则跳出循环，并返回true			if(curpos.x==end.x&&curpos.y==end.y){				//把出口结点放入路径中				push(realPath,curpos);				push(path,curpos);				//直接跳出函数(而不只是跳出循环)				return;			}else if(curpos.val==-1){//当前位置的四面或为墙或已走过				//删除真实路径的栈顶元素				pop(realPath);				curpos = getTop(realPath);//令curpos指向栈顶元素			}		}else{//如果当前位置已经走过，说明原来测试的方向不对，现在尝试其他方向			curpos = getNext(path,curpos);			if(curpos.val==-1){//仍不通，删除真实路径的栈顶元素				pop(realPath);				curpos = getTop(realPath);//令curpos指向栈顶元素			}		}	}while(curpos.x!=end.x||curpos.y!=end.y);}void printMazePath(sLink realPath){	/*注：这种方法实际上是倒序打印出路径，让人看着别扭，所以用下面的方法“倒序遍历这个栈”	eLink p = realPath->top-1;	while(p!=realPath->base){		printf("maze[%d][%d]---->",p->x,p->y);		p--;	}	*/	eLink p = realPath->base;	while(p<realPath->top-1){		printf("maze[%d][%d]---->",p->x,p->y);		p++;	}	//最后一个结点没有后继，所以不再输出"----->"	printf("maze[%d][%d]",p->x,p->y);}void main(){	//来源：http://hi.baidu.com/linfengtingyu1/blog/item/0de5840e254fece7aa64576d.html	//求解迷宫的相关操作	//构造两个栈	sLink realPath=initStack();//构造空栈S，保存有效路径	sLink path=initStack();//构造空栈S，保存探索中的全部路径	getMazePath(realPath,path);	printf("allpath length is = %d realpath length is = %d",stackLength(path),stackLength(realPath));	printf("\nAll the path of through the maze is:\n");	printMazePath(path);	printf("\n\nThe real path of through the maze is:\n");    printMazePath(realPath);}