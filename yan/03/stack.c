/***********声明部分***************///栈的顺序存储表示和实现，类似数组#include<stdio.h> //输入输出函数头文件#include<stdlib.h> //内存申请函数头文件#define false 0#define true 1#define error false //异常抛出返回值#define STACK_INIT_SIZE 100 //定义最初申请的内存的大小#define STACKINCREMENT 2 //每一次申请内存不足的时候扩展的大小/*顺序栈结构体定义部分*/typedef struct{	elemType *base;//栈底指针，在栈构造之前和销毁之后，base为NULL	elemType *top;//栈顶指针，初值指向栈底，top=base可做栈空标记	//插入新栈顶元素时，top增1；删除栈顶元素时，top减1	//非空栈的top始终在栈顶元素的下一个位置上	int stackSize;//当前已分配的存储空间，以元素为单位}Stack,*sLink;//指向elemType数据类型的指针#define eLink elemType *//elemType数据类型所占空间大小#define Len sizeof(elemType)/*函数声明区域*/sLink initStack();//构造一个空栈void destoryStack(sLink);//销毁栈void clearStack(sLink);//清空栈int stackEmpty(sLink);//判断是否为空栈int stackLength(sLink);//返回栈中数据元素的个数elemType getTop(sLink);//返回栈顶元素void push(sLink,elemType);//插入元素e为新的栈顶元素elemType pop(sLink);//删除栈顶元素void stackOut(sLink);//输出多项式内容//构造一个空栈sLink initStack(){	sLink S;//S是指向一个空栈的指针	//注意一定要为指向栈的指针申请内存空间，使用Stack S就是初始化时申请内存。	S = (sLink)malloc(sizeof(Stack));	S->base = (eLink)malloc(STACK_INIT_SIZE*Len);	if(!S->base) exit(error);//存储分配失败	S->top = S->base;//空栈的栈顶指针等于栈底指针	S->stackSize = STACK_INIT_SIZE;//初始化栈的容量	return S;}//销毁栈void destroyStack(sLink S){	free(S->base);//销毁数据元素	free(S);//销毁栈	S = NULL;}//清空栈void clearStack(sLink S){	free(S->base);	S->base = S->top;	S->stackSize = STACK_INIT_SIZE;//初始化栈的容量}//判断是否为空栈int stackEmpty(sLink S){	//栈顶指针S->top是否等于栈底指针S->base是判断栈是否为空的条件	if(S->top==S->base) return true;	else return false;}//返回栈中数据元素的个数int stackLength(sLink S){	return S->top - S->base;}/*返回栈顶元素*/elemType getTop(sLink S){	//若栈不空，则返回S的栈顶元素，否则error	if(S->top==S->base) return;	return *(S->top-1);}//插入元素e为新的栈顶元素void push(sLink S,elemType e){	//栈满，追加存储空间，注S的存储地址没有变化	if(S->top-S->base>=S->stackSize){		S->base = (eLink)realloc(S->base,(S->stackSize+STACKINCREMENT)*Len);		if(!S->base) exit(error);//存储分配失败		S->top = S->base + S->stackSize;//S->base地址可能发生变化，所以S->top要重新赋值		S->stackSize += STACKINCREMENT;	}	*S->top++ = e;//先赋值在递增，即*(S->top)++}/*删除栈顶元素,LIFO(Last In First Out)*/elemType pop(sLink S){	elemType e;	//若栈不为空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR	if(S->top==S->base) return;	e = *--S->top;	return e;}/*输出多项式内容*/void stackOut(sLink S){	eLink q = S->base;	if(S->base==S->top) return;	while(q!=S->top){		printf(D,*q++);	}}