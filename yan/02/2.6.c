/***********声明部分***************///一元多项式求值#include<stdio.h> //输入输出函数头文件#include<stdlib.h> //内存申请函数头文件#define false 0#define true 1#define error false //异常抛出返回值#define NL "\n" //格式化输出函数#define F "%d "#define D "%3.2f"#define DL D NLtypedef float elemType;//别名声明，其实int可以用任意的数据类型代入/*结构体定义部分:将一元多项式定义为*/typedef struct Polynomial{//circle node	elemType coef;//系数	int expn;//指数	struct Polynomial *next;//指针域}term,*pLink;#define Len sizeof(term) //*Link = CN/*函数声明区域*/pLink createPolyn();//构造一个空的带头结点的单循环链表Pvoid destoryPolyn(pLink P);//销毁一元多项式单循环链表Pint polynLength(pLink);//返回L中数据元素的个数void polynInsert(pLink,elemType,int);//在多项式中插入元素，使多项式按照指数的升序排序elemType polynDelete(pLink,int x);//删除指数为x的元素void polynAdd(pLink,pLink);//一元多项式相加void polynMultiply(pLink,pLink,pLink);//一元多项式相乘void polynOut(pLink);//输出多项式内容/*构造一个空的带头结点的单循环链表P*/pLink createPolyn(){	/*操作结果：构造一个空的线性表P*/	pLink P;	P = (pLink)malloc(Len);//产生头结点，并使P指向此头结点	if(!P){//存储分配失败		exit(false);	}	P->next = P;//指针域指向头结点	return P;}/*销毁一元多项式单循环链表P*/void destoryPolyn(pLink P){	pLink s=P->next,q;	while(s!=P){		q = s->next;		free(s);//销毁s指向的元素		s = q;	}	free(P);//释放头结点	P = NULL;}/*返回P中数据元素的个数*/int polynLength(pLink P){	int i=0;	pLink s = P->next;//s指向第一个元素结点，非头结点元素	while(s!=P){//没到表尾		i++;		s = s->next;	}	return i;}/*在一元多项式P中比x大的元素前插入元素e*/void polynInsert(pLink P,elemType e,int x){//P带头结点，指数项x从0开始	pLink q=P,s;//q指向头结点	while(q->next!=P){		if(q->next->expn >=x){						break;		}		q = q->next;	}	//相等则相加	if(q->next->expn==x){		q->next->coef += e;		return;	}	s = (pLink)malloc(Len);//生成新结点	s->coef = e;//系数	s->expn = x;//指数	//将s节点插入一元多项式中	s->next = q->next;	q->next = s;}/*删除指数项为x的元素，并由x对应系数项*/elemType polynDelete(pLink P,int x){	pLink s,q=P;//q指向头结点	elemType e;	while(q->next!=P){		if(q->next->expn==x) break;		q = q->next;	}	//没有找到	if(q->next==P) return error;	s = q->next;//q指向待删除的节点	q->next = s->next;	e = s->coef;	free(s);//释放待删除结点	return e;}/*一元多项式相加*/void polynAdd(pLink P1,pLink P2){	pLink s1=P1,s2=P2,tmp;	while(s1->next!=P1&&s2->next!=P2){		//如果指数相等，则相加		if(s1->next->expn == s2->next->expn){			s1->next->coef+=s2->next->coef;//系数相加			s1=s1->next;s2=s2->next;		}else if(s1->next->expn > s2->next->expn){//P1指数大于P2，将P2添加到P1			//将s2从P2中删除			tmp = s2->next;			s2->next = tmp->next;			//将tmp插入到P1中			tmp->next = s1->next;			s1->next = tmp;			//s2 = s2->next;//这里不用指向下一个元素，因为以前对应的s2->next已经从P2中删除		}else if(s1->next->expn < s2->next->expn){//P1指数大于P2，将P2添加到P1			s1 = s1->next;		}	}	//将剩余P2加入到P1中	if(s2->next!=P2){		s1->next = s2->next;		//删除P2中剩余结点		s2->next = P2;		while(s1->next!=P2) s1=s1->next;		//改变添加了剩余P2的尾结点为P1的头结点		s1->next=P1;	}	//销毁P2多项式	destoryPolyn(P2);}/*一元多项式相乘*/void polynMultiply(pLink P1,pLink P2,pLink P3){	pLink s1=P1,s2;	elemType e;//系数	int x;//指数	while(s1->next!=P1){		s2 = P2;		//p1每个项都和p2中每个项相乘		while(s2->next!=P2){			e = s1->next->coef * s2->next->coef;			x = s1->next->expn+s2->next->expn;			//将新的元素项插入到P3中			polynInsert(P3,e,x);			s2 = s2->next;		}		s1 = s1->next;	}}//输出多项式内容void polynOut(pLink P){	pLink s = P->next;	while(s!=P){		printf(D"X%d ",s->coef,s->expn);		s = s->next;	}}#define N 3void main(){	int i;	pLink P1 = createPolyn(),P2 = createPolyn(),P3 = createPolyn();//一元多项式P1,P2	elemType coef1[N]={12.4,-15,9.5},coef2[N+1]={-3.4,10.1,-9.5,-2.5},e;//系数	int expn1[N]={2,5,9},expn2[N+1]={5,0,3,12};//指数	//P1中插入元素	for(i=0;i<N;i++){		polynInsert(P1,coef1[i],expn1[i]);	}	//输出一元多项式P1	printf("Polynomial One length:%d\n",polynLength(P1));	polynOut(P1);	//从一元多项式P1中删除指数为2的元素	e = polynDelete(P1,0);//指数为0可能没有找到需要删除的元素	printf("\n\nPolynomial One length %d after delete element:"DL,polynLength(P1),e);	polynOut(P1);		//P2中插入元素	for(i=0;i<N+1;i++){		polynInsert(P2,coef2[i],expn2[i]);	}	//输出一元多项式P2	printf("\n\nPolynomial Two length:%d\n",polynLength(P2));	polynOut(P2);	//从一元多项式P2中删除指数为3的元素	e = polynDelete(P2,10);//指数为0可能没有找到需要删除的元素	printf("\n\nPolynomial Two length %d after delete element:"DL,polynLength(P2),e);	polynOut(P2);		//一元多项式相乘	polynMultiply(P1,P2,P3);	printf("\n\nPolynomial Three length %d after multipling P1 and P2\n",polynLength(P3));	polynOut(P3);		//一元多项式P1,P2相加	polynAdd(P1,P2);	printf("\n\nPolynomial One and Two length %d after adding.\n",polynLength(P1));	polynOut(P1);}