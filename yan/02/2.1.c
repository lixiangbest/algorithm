/***********声明部分***************/#include<stdio.h> //输入输出函数头文件#include<stdlib.h> //内存申请函数头文件#define false 0#define true 1#define LIST_INIT_SIZE 10 //定义最初申请的内存的大小#define LIST_INCREMENT 2 //每一次申请内存不足的时候扩展的大小#define OVERFLOW false //异常抛出返回值#define ERROR false //异常抛出返回值#define INFEASIBLE false //异常抛出返回值#define OK true //程序正确执行抛出返回值typedef int ElemType;//别名声明，其实int可以用任意的数据类型代入typedef int bool;//别名声明/*结构体定义部分*/typedef struct{//顺序结构的名字	ElemType *elem;//存储空间基址	int length;//当前长度,即元素的有效长度	int listsize;//当前分配的存储容量，以sizeof(ElemType)作为单位}sqList;/*函数声明区域*/void initList(sqList *L);//构造一个空的顺序线性表Lbool destroyList(sqList *L);//销毁线性表Lbool listEmpty(sqList *L);//判断线性表是否为空bool listFull(sqList *L);//判断线性表是否已满int listLength(sqList *L);//线性表的长度void outList(sqList *L);//线性表输出ElemType getElement(sqList *L,int);//获得线性表索引对应的值bool listInsert(sqList *L, int i, ElemType e);//线性表的插入bool listDelete(sqList *L, int i);//线性表的删除void listTraverse(sqList *L);//线性表转置void listSort(sqList *L);//冒泡排序int locateElement(sqList *L, ElemType e);//查找线性表相关元素对应的位序索引int compare(int x, int y);//数据元素比较函数void unionList(sqList *La, sqList *Lb);//线性表联合函数void mergeList(sqList *La, sqList *Lb, sqList *Lc);//使用插值方法合并，可以包含重复的元素void mergeListAssign(sqList *La, sqList *Lb, sqList *Lc);//使用赋值方法合并，可以包含重复的元素/*************** 基本操作函数开始 *******************//*构造一个空的顺序线性表L*/void initList(sqList *L){	//初始条件：无	(*L).elem = (ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType));	if(!(*L).elem){		printf("fail to malloc!");		exit(OVERFLOW);//存储分配失败	}	(*L).length = 0;//空表长度为0	(*L).listsize = LIST_INIT_SIZE;//初始化存储容量，即存储的线性表元素个数}/*销毁线性表*/bool destroyList(sqList *L){	if(!listEmpty(L)){		free(L);		return true;	}	return false;}/*判断线性表是否为空*/bool listEmpty(sqList *L){	//判断申请的线性表的大小	if(0==L->length) return true;	else return false;}/*判断线性表是否已满*/bool listFull(sqList *L){	if(L->length == L->listsize) return true;	else return false;}/*返回线性表的长度*/int listLength(sqList *L){	return L->length;}/*用返回L中第position个所在的数据元素*/ElemType getElement(sqList *L, int position){	return L->elem[position-1];}/*比较函数*/bool compare(int x,int y){	//比较函数，第一个与第二个不相等就返回true	if(x!=y) return true;	else return false;}/*返回L中第1个与e满足关系compare()的数据元素的位序*/bool locateElement(sqList *L, ElemType e){	ElemType *p;	int i=1;//i的初值为第一个元素的位序	p = L->elem;//p的初值为第一个元素的存储位置	while(i<=L->length&&compare(*p++,e)){		i++;	}	if(i<=L->length) return i;	else return false;}/*在L中的第i个位置之前插入新的数据元素e，L的长度加1*/bool listInsert(sqList *L, int i, ElemType e){	//初始条件：顺序表已经存在，1<=i<=listLength(L)+1	//i的合法值为1<=i<=listLength+1	ElemType *newbase,*q,*p;	if(i<1||i>L->length+1){//i值不合法		return ERROR;	}	if(L->length>=L->listsize){//当前存储空间已满，增加分配		if(!(newbase=(ElemType*)realloc(L->elem,(L->listsize+LIST_INCREMENT)*sizeof(ElemType))))			exit(OVERFLOW);//存储分配失败		L->elem = newbase;//新基址		L->listsize += LIST_INCREMENT;//增加存储容量	}	q = L->elem+i-1;	//这里L->elem+L->length地址对应空间存在	for(p=L->elem+L->length-1;p>=q;--p){		*(p+1) = *p;	}	*q = e;//插入e	L->length++;//表长加1	return OK;}/*在L中删除第i个位置的元素，并用e返回其值*/ElemType listDelete(sqList *L, int i){	//i的合法值为1<=i<=listLength(L)+1	ElemType e,*p;	if(i<1||i>L->length) return ERROR;//i值不合法	p = &(L->elem[i-1]);//p为被删除元素的位置	e = *p;//被删除的元素的值赋给e	for(++p;p<L->elem+L->length;p++){		*(p-1) = *p;//被删除元素之后的元素左移	}	L->length--;//表长减1	return e;}/*线性表转置*/void listTraverse(sqList *L){	/*	//两种方法转置	int i=0;	int j=L->length-1;	ElemType t;	while(i<j){		t = L->elem[i];		L->elem[i] = L->elem[j];		L->elem[j] = t;		i++;		j--;	}	*/	int i=0;	int j=L->length/2;	ElemType t;	while(i<j){		t = L->elem[L->length-i-1];		L->elem[L->length-i-1] = L->elem[i];		L->elem[i] = t;		i++;	}}/*冒泡排序*/void listSort(sqList *L){	int i,j;	ElemType t;	for(i=0;i<L->length;i++){//排序次数		for(j=1;j<L->length-i;j++){			if(L->elem[j-1] < L->elem[j]){				t = L->elem[j-1];				L->elem[j-1] = L->elem[j];				L->elem[j] = t;			}		}	}}/*线性表输出函数*/void outList(sqList *L){	int i;	//如果线性表为空	if(listEmpty(L)){		printf("List is empty\n");	}else{//如果数组不为空		for(i=0;i<L->length;i++){			printf("%d ",L->elem[i]);		}		printf("\n");	}}/**************** 基本操作函数结束 *******************//*在数组末尾追加元素的函数*/bool appendElement(sqList *L, ElemType value){	//满时返回false	if(listFull(L)) return false;	//不满时追加	L->elem[L->length] = value;	L->length++;	return true;}//将线性表La,Lb组成一个新的集合。即扩大线性表La.void unionList(sqList *La, sqList *Lb){	//将所有在线性表Lb中但不在La中的数据元素插入到La中	int i;	ElemType e;	for(i=0;i<Lb->length;i++){		e = getElement(Lb,i+1);//取Lb中第i个数据元素赋给e		if(!locateElement(La,e)) listInsert(La,La->length+1,e);//La中不存在和e相同的数据元素，则插入之	}}/*使用插值方法合并，可以包含重复的元素*/void mergeList(sqList *La, sqList *Lb, sqList *Lc){	//已知线性表La和Lb中的数据元素按值非递减排列	//归并La和Lb得到新的线性表Lc，Lc的数据元素也按值非递减排列	int i=0,j,k,len_1=listLength(La),len_2=listLength(Lb);	j=k=0;	ElemType e1,e2;	while(i<len_1&&j<len_2){//La和Lb均非空		e1 = getElement(La,i+1);		e2 = getElement(Lb,j+1);		if(e1<e2){listInsert(Lc,++k,e1);i++;}		else{listInsert(Lc,++k,e2);j++;}	}	//两个while执行一个循环体	while(i<len_1){		e1 = getElement(La,++i);		listInsert(Lc,++k,e1);	}	while(j<len_2){		e2 = getElement(Lb,++j);		listInsert(Lc,++k,e2);	}}/*使用赋值方法合并，可以包含重复的元素*/void mergeListAssign(sqList *La, sqList *Lb, sqList *Lc){	//已知顺序表La和Lb的元素按值非递减排列	//归并La和Lb得到新的顺序线性表Lc，Lc的元素也按值非递减排列	ElemType *pa = La->elem,*pb = Lb->elem;	ElemType *pa_last = pa+La->length-1,*pb_last = pb+Lb->length-1,*pc;	Lc->elem = pc = (ElemType *)realloc(Lc->elem,(La->length+Lb->length)*sizeof(ElemType));	while(pa<=pa_last&&pb<=pb_last){//归并		if(*pa>*pb) *pc++ = *pa++;//把较大的先插入到线性表中		else *pc++ = *pb++;		Lc->length++;	}	while(pa<=pa_last){		*pc++ = *pa++;//插入La的剩余元素		Lc->length++;	}	while(pb<=pb_last){		*pc++ = *pb++;//插入Lb的剩余元素		Lc->length++;	}}/*程序执行区域*/void main(){	/*程序执行区域*/	int i;	sqList La,Lb,Lc,Ld,Lm;//定义顺序表La,Lb	//线性表La	printf("/**La list elements**/\n");	initList(&La);	for(i=0;i<LIST_INIT_SIZE;i++){		appendElement(&La,(i+4));	}	outList(&La);	printf("La list length:%d\n", listLength(&La));	printf("Position 2 is:%d\n", getElement(&La,2));	if(listInsert(&La,3,20)) outList(&La);	if(listInsert(&La,7,2)) outList(&La);	if(listInsert(&La,5,14)) outList(&La);	printf("La list length:%d\n", listLength(&La));	printf("La delete the %d element is %d\n", 2, listDelete(&La,2));	outList(&La);	printf("La traverse:\n");	listTraverse(&La);	outList(&La);	printf("La bubber sort:\n");	listSort(&La);	outList(&La);		//线性表Lb	printf("\n/**Lb list elements**/\n");	initList(&Lb);	for(i=0;i<LIST_INIT_SIZE-5;i++){		appendElement(&Lb,i+5);	}	outList(&Lb);		//联合后的线性表不包含重复元素	printf("\n/**Union La and Lb list elements**/\n");	unionList(&La,&Lb);//把B表插入到A表中	outList(&La);		//使用插值法合并线性表包括重复元素	printf("\n/**Union La and Lb list elements is Lc**/\n");	initList(&Lc);	mergeList(&La,&Lb,&Lc);	outList(&Lc);	printf("the sorted Lc\n");	listSort(&Lc);	outList(&Lc);		//线性表Ld	printf("\n/**Ld list elements**/\n");	initList(&Ld);	appendElement(&Ld,26);appendElement(&Ld,1);appendElement(&Ld,1);appendElement(&Ld,16);	outList(&Ld);	printf("the sorted Lc\n");	listSort(&Ld);	outList(&Ld);		//使用赋值法合并线性表包括重复元素	printf("\n/**Union Lc and Ld list elements is Lm**/\n");	initList(&Lm);	mergeListAssign(&Lc,&Ld,&Lm);	outList(&Lm);		destroyList(&Lm);//some problem}